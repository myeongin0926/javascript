순서가 있는 걸렉션을 다뤄야 할 때 객체를 사용하면 순서와 관련된 메서드가 없어
다소 불편함을 느낄겁니다. 객체는 애초에 순서를 고려하지 않기에 새로운 프로퍼티를
기존 프로퍼티 '사이에' 끼워 넣는 것도 불가능합니다.

이럴 땐 순서가 있는 컬렉션을 저장할 때 쓰이는 자료구조인 배열을 사용할 수 있습니다.

배열 선언
아래 두 문법을 사용하여 빈 배열을 만들 수 있습니다.

let arr = new Array();
let arr = [];
대부분 두 번째 방법으로 배열을 선언하는데, 이때 대괄호 안에 초기 요소를 넣어줄 수 있습니다.

let color = ["red", "blue", "yellow"];
각 배열 요소엔 0부터 시작하는 숫자(인덱스)가 매겨져 있습니다. 이 숫자는 배열 내 순서를 나타냅니다.

배열 내 특정 요소를 얻고 싶다면 대괄호 안에 순서를 나타내는 숫자인 인덱스를 넣어주면 됩니다.

let color = ["red", "blue", "yellow"];

alert( color[0] ); //red
alert( color[1] ); //blue
alert( color[2] ); //yellow
같은 방법으로 요소를 수정할 수 있습니다.

color[2] = "white"; // 배열을 수정합니다["red", "blue", "white"]
새로운 요소를 배열에 추가할 수 있습니다.

color[3] = "pink"' // 배열을 수정합니다["red", "blue", "white", "pink"]
length를 사용하면 배열에 담긴 요소가 몇 개인지 알아낼 수 있습니다.

let color = ["red", "blue", "yellow"];

alert( color.lenth ); //3
alert를 사용하면 전체 요소를 출력할 수 있습니다.

let color = ["red", "blue", "yellow"];

alert( color ); //red, blue, yellow
배열 요소의 자료형엔 제약이 없습니다.

// 요소에 여러 가지 자료형이 섞여 있습니다.
let arr = [ '사과', { name: '이보라' }, true, function() { alert('안녕하세요.'); } ];

// 인덱스가 1인 요소(객체)의 name 프로퍼티를 출력합니다.
alert( arr[1].name ); // 이보라

// 인덱스가 3인 요소(함수)를 실행합니다.
arr[3](); // 안녕하세요.
trailing 쉼표
배열의 마지막 요소는 객체와 마찬가지로 쉼표로 끝날 수 있습니다.

let fruits = [
  "사과",
  "오렌지",
  "자두",
];
trailing 쉼표를 사용하면 모든 줄의 생김새가 유사해지기 때문에 요소를 넣거나 빼기가 쉬워집니다.

pop·push와 shift·unshift
큐는 배열을 사용해 만들 수 있는 대표적인 자료구조로,
배열과 마찬가지로 순서가 있는 컬렉션을 저장하는 데 사용합니다.
큐에서 사용하는 주요 연산은 아래와 같습니다.

push – 맨 끝에 요소를 추가합니다.
shift – 제일 앞 요소를 꺼내 제거한 후 남아있는 요소들을 앞으로 밀어줍니다. 이렇게 하면 두 번째 요소가 첫 번째 요소가 됩니다.

배열엔 두 연산을 가능케 해주는 내장 메서드 push와 pop이 있습니다.

화면에 순차적으로 띄울 메시지를 비축해 놓을 자료 구조를 만들 때 큐를 사용하는 것처럼
큐는 실무에서 상당히 자주 쓰이는 자료구조입니다.

배열은 큐 이외에 스택(stack)이라 불리는 자료구조를 구현할 때도 쓰입니다.

스택에서 사용하는 연산은 아래와 같습니다.

push – 요소를 스택 끝에 집어넣습니다.
pop – 스택 끝 요소를 추출합니다.
스택은 이처럼 '한쪽 끝’에 요소를 더하거나 뺄 수 있게 해주는 자료구조입니다.

아래는 배열 끝에 무언가를 해주는 메서드입니다.
pop
배열 끝의 요소를 제거하고, 제거한 요소를 반환

let fruits = ["사과", "오렌지", "배"];

alert( fruits.pop() ); // 배열에서 "배"를 제거하고 제거된 요소를 얼럿창에 띄웁니다.

alert( fruits ); // 사과,오렌지
push
배열 끝에 요소를 추가합니다.

let fruits = ["사과", "오렌지"];

fruits.push("배");

alert( fruits ); // 사과,오렌지,배
아래는 배열 앞에 무언가를 해주는 메서드입니다.
shift
배열 앞 요소를 제거하고 제거한 요소를 반환합니다.

let fruits = ["사과", "오렌지", "배"];

alert( fruits.shift() ); // 배열에서 "사과"를 제거하고 제거된 요소를 얼럿창에 띄웁니다.

alert( fruits ); // 오렌지,배
unshift
배열 앞에 요소를 추가합니다.

let fruits = ["오렌지", "배"];

fruits.unshift('사과');

alert( fruits ); // 사과,오렌지,배
push와 unshift는 요소 여러 개를 한 번에 더해줄 수도 있습니다.

let fruits = ["사과"];

fruits.push("오렌지", "배");
fruits.unshift("파인애플", "레몬");

// ["파인애플", "레몬", "사과", "오렌지", "배"]
alert( fruits );
배열의 내부 동작 원리
배열은 arr 요소를 arr[]처럼 대괄호를 사용해 접근하는 방식을 객체 문법에서 가져왔습니다.
다만, 배열은 키가 숫자라는 점이 객체와 다릅니다. 객체는 키:값을 따로 정함

숫자형 키를 사용함으로써 배열은 객체 기본 기능 이외에도
순서가 있는 컬렉션을 제어하게 해주는 특별한 메서드를 제공합니다.
length라는 프로퍼티도 제공하죠. 그렇지만 어쨌든 배열의 본질은 객체입니다.

이렇게 배열은 자바스크립트의 일곱 가지 원시 자료형에 해당하지 않고,
원시 자료형이 아닌 객체형에 속하기 때문에 객체처럼 동작합니다.

예시를 하나 살펴봅시다. 배열은 객체와 마찬가지로 참조를 통해 복사됩니다.

let fruits = ["바나나"]

let arr = fruits; // 참조를 복사함(두 변수가 같은 객체를 참조)

alert( arr === fruits ); // true

arr.push("배"); // 참조를 이용해 배열을 수정합니다.

alert( fruits ); // 바나나,배 - 요소가 두 개가 되었습니다.
배열은 객체이므로 객체처럼 원하는 프로퍼티를 키로 사용해도 문제가 발생하지 않습니다.
그런데 이렇게 코드를 작성하면 배열을 일반 객체처럼 다루게되어 배열의 이점이 사라집니다.

잘못된 예
1.arr.test = 5 같이 숫자가 아닌 값을 프로퍼티 키로 사용하는 경우
2.arr[0]과 arr[1000]만 추가하고 그사이에 아무런 요소도 없는 경우
3.arr[1000], arr[999]같이 요소를 역순으로 채우는 경우

배열은 순서가 있는 자료를 저장하는 용도로 만들어진 특수한 자료구조입니다.
배열 내장 메서드들은 이런 용도에 맞게 만들어졌죠.
자바스크립트 엔진은 이런 특성을 고려하여 배열을 신중하게 조정하고,
처리하므로 배열을 사용할 땐 이런 목적에 맞게 사용해 주시기 바랍니다.
임의의 키를 사용해야 한다면 배열보단 일반 객체 {}가 적합한 자료구조일 확률이 높습니다.

성능
push, pop(배열 뒤에 무언가를 해주는 요소)는 빠르지만
shift, unshift(배열 앞에 무언가를 해주는 요소)는 느립니다.

배열 앞에 무언가를 해주는 메서드가 배열 끝에 무언가를 해주는 메서드보다 느린 이유를
실행 흐름을 살펴보면서 알아보겠습니다.

fruits.shift(); // 배열 맨 앞의 요소를 빼줍니다.
shift 메서드는 배열 맨 앞의 요소를 빼주는것 입니다.
인덱스가 0인 요소를 제거하는것만으로 끝이 아니죠,
제거 대상이 아닌 나머지 요소들의 인덱스를 수정해주어야 합니다.

인덱스가 0인 요소를 제거합니다.
모든 요소를 왼쪽으로 이동시킵니다. (인덱스 1은 0, 2는 1)로 변합니다.
length 프로퍼티의 값을 갱신시킵니다.
배열에 요소가 많으면 이동하는데 시간이 오래 걸리게되고 메모리 관련 연산도 많아집니다.

unshift도 마찬가지로 앞에 요소를 추가해주려면 모든 인덱스를 오른쪽으로 이동시켜주어야 하는데
이때 인덱스도 바꿔주어야 합니다.

하지만 pop과push는 이 둘은 요소를 이동시키지 않습니다.
맨 뒤에 요소를 관리하는것이기에 length프로퍼티의 값을 조절해주면 되기 때문입니다.

fruits.pop(); // 배열 끝 요소 하나를 제거합니다.
pop 메서드는 요소를 옮기지 않으므로 각 요소는 기존 인덱스를 그대로 유지합니다.
배열 끝에 무언가를 해주는 메서드의 실행 속도가 빠른 이유는 바로 여기에 있습니다.

push 메서드를 쓸 때도 유사한 동작이 일어나므로 속도가 빠릅니다.

반복문
for문은 배열을 순회할 때 쓰는 가장 오래된 방법이다
순회시엔 인덱스를 사용.

let user_name = ["john","jenny","tom","stan"];

for (let i = 0; i<user_name.length; i++){
  alert(user_name[i]);
}
length 프로퍼티
배열에 무언가 조작을 가하면 length 프로퍼티가 자동 갱신됨

lengrh 프로퍼티는 배열 내에 요소의 개수가 아닌 가장 큰 인덱스에 1을 더한것
따라서 배열에 요소가 하나여도 인덱스가 아주 큰 정수라면 배열의 length 프로퍼티도 커짐.

let user = [];
user[99] = "john";

alert(user.length); //100
length 프로퍼티는 쓰기가 가능함.
length의 값을 수동으로 증가시켜도 아무일이 일어나지 않지만, 값을 감소시키면 배열이 잘림.
잘라진 배열은 다시 되돌릴 수 없음.
let arr = [1, 2, 3, 4, 5];

arr.length = 2; // 요소 2개만 남기고 잘라봅시다.
alert( arr ); // [1, 2]

arr.length = 5; // 본래 길이로 되돌려 봅시다.
alert( arr[3] ); // undefined: 삭제된 기존 요소들이 복구되지 않습니다.
이런 특징을 이용해 arr.length = 0;을 사용해 배열을 비울 수 있음.
new Array()
대괄호를 사용해서 배열을 만드는것이 훨씬 편리함
다루기 까다로운 기능들이 있음
위의 것들을 종합하여 대부분 개발자들은 대괄호를 써서 배열을 만듦
다차원 배열
배열의 요소안에 배열을 넣는것. 이것을 다차원 배열이라함
다차원 배열은 행렬을 저장하는 용도로 쓰임
let matrix = [
  [1, 2, 3],
  [4, 5, 6],
  [7, 8, 9]
];

alert( matrix[1][1] ); // 5, 중심에 있는 요소
toString
배열엔 toString메서드가 구현되어 있어 이를 호출하면 요소를 쉼표로 구분한 문자열이 반환.
alert( [] + 1 ); // "1"
alert( [1] + 1 ); // "11"
alert( [1,2] + 1 ); // "1,21"